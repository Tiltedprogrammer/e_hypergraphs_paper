\section{Application --- $\lambda^\approx_{\text{lsub}}$-calculus}
\label{sec:application}

In this section, we show the utility of our theory by demonstrating how it can accommodate the \emph{linear substitution calculus} $\lambda_{\text{lsub}}$ of~\citet[ยง 2]{accattoli2014nonstandard}.
We summarise the linear substitution calculus as the $\lambda$-calculus with an additional term former representing explicit substitution; i.e.\ terms are generated by the grammar
\[
	t \coloneqq x \mid t t \mid \lambda x. t \mid t [x/t],
\]
where $x$ is a variable drawn from some countably infinite set, $t u$ is an application, and $\lambda x. t$ is an abstraction, as in standard $\lambda$-calculus.
The term $t [x / u]$ is an explicit substitution of the variable $x$ for the term $u$ in the term $t$.

The notions of context $C[-]$, bound and free variable are as usual, with the addition that $\textsf{fv} (t [x/u]) \coloneq \textsf{fv} (t) \setminus \{ x \} \cup \textsf{fv} (u)$.
Write $C \llbracket t \rrbracket$ for the term given by substitution of the hole in the context $C[-]$ for the term $t$, under the additional restriction that the free variables of $t$ are not captured (via abstraction or explicit substitution) by $C$.
In addition to the $\beta$- and $\eta$-reduction rules of standard $\lambda$-calculus, there are reduction rules to account for this explicit substitution which \enquote{perform} the substitution or commute it with $\beta$-reduction:
\begin{align*}
	(\lambda x. t) L u              \quad & \to_{d\beta} \quad t[x/u] L,                                                \\
	C \llbracket x \rrbracket [x/t] \quad & \to_{ls} \quad C \llbracket u \rrbracket [x/t],                             \\
	t [x/u]                         \quad & \to_{gc} \quad t,                               & x \notin \textsf{fv} (t),
\end{align*}
where $L$ is a finite list of substitutions of the form $[x/u] [y/v] \ldots$.

In programming terms, this explicit substitution can be used to model \textbf{let}-bindings and sharing.
For instance, the ML-style term $\textbf{let} \; x = 1 \; \textbf{in} \; \text{plus} (x, x)$ is formally represented as the term $\text{plus} (x, x) [x / 1]$ in this calculus\footnote{Technically speaking, in this case we mean the extension of this calculus with flat natural numbers equipped with a binary operation $\text{plus}$.}.
In this case, the variable $x$ is valued in the constant $1$, but one could imagine instead that $x$ is to be substituted for the result of some expensive computation which we do not desire to repeat twice unnecessarily --- in this sense, the sharing of both operands of the operation $\text{plus}$ is captured by the explicit substitution.

\emph{Graphical equivalence} $\sim$ of $\lambda_{\text{lsub}}$-terms is augmentation of $\alpha$-equivalence of terms with the additional stipulations that
\begin{align}
	t [x/u] [y/v] \quad        & \sim \quad t [y/v] [x/u],        & x \notin \textsf{fv} (v) \land y \notin \textsf{fv} (u), \nonumber \\
	\label{eq:subst-lambda}
	(\lambda y. t) [x/u] \quad & \sim \quad \lambda y. (t [x/u]), & y \notin \textsf{fv} (u), \tag{$\ast$}                             \\
	(t v) [x/u] \quad          & \sim \quad t [x/u] v,            & x \notin \textsf{fv} (v), \nonumber
\end{align}
closed under contexts, transitivity, symmetry, and reflexivity.
Put simply, it is the stipulation that \textbf{let}-bindings may be freely reordered without changing the meaning of the term\footnote{Recall that our setting is \emph{pure}, in the sense that no sequencing of effects is meaningful.}.
The $\lambda^\sim_{\text{lsub}}$-calculus is given by these graphical equivalence classes of terms with the reduction relation defined by that of the $\lambda_{\text{lsub}}$-calculus modulo graphical equivalence.

This calculus is explicitly designed to capture the representation of terms as proof nets: for two terms $t, u$ in the $\lambda_{\text{lsub}}$-calculus, $t \sim u$ if and only if both map to the same proof net~\cite{?}.
By further extending the equivalence relation $\sim$, taking the symmetric closure by $\to_{ls}$ and $\to_{gc}$ and thus identifying terms under elimination of explicit substitution, we determine a \emph{string diagram equivalence} $\approx$ of $\lambda_{\text{lsub}}$-terms, determining a $\lambda^\approx_{\text{lsub}}$-calculus.
Predictably, $t \approx u$ if and only if both map to the same string diagram~\cite[ยง 5.1.1]{ghica2024stringdiagramslambdacalculifunctional}; this allows us to exploit the string diagram setting of e-hypergraphs to absorb many\footnote{The reason this is not \emph{all} reductions is because e-hypergraphs quotient away only the \emph{structural} isomorphisms of symmetric monoidal closed $\catname{SLat}$-categories (e.g.\ associators, unitors, etc.) which generate the \enquote{isotopy of string diagrams}; even in the graphical equivalence relation $\sim$, while~\autoref{eq:subst-lambda} is validated in every symmetric monoidal closed $\catname{SLat}$-category, it is not so by isotopy, but rather the adjunction $A \multimap - \dashv - \otimes A$. In other words, terms floating freely through the boundaries of rounded boxes is validated by our semantics, but produces concretely different e-hypergraphs --- this is the purpose of rectification by quotienting along $\mathcal{S}$ in~\autoref{prop:quotient-structural}, and manifests as additional DPO rewrites to be imposed.} of the reductions arising due to the equivalence $\approx$ into our representation rather than explicitly providing them as equations attached to a closed symmetric monoidal theory presenting the $\lambda^\approx_{\text{lsub}}$-calculus.

Before we proceed to demonstrate this, we first wish to discuss the relevance of this calculus in the domain of e-graphs.
E-graphs excel as a toolkit for compiler optimisation, facilitating the rewriting of programs into more efficient forms by equality saturation.
The theoretical study of this is the field of term rewriting, where programs are often simplistically represented as (the abstract syntax of) terms in the $\lambda$-calculus.
However, in a modern optimising compiler (e.g.\ LLVM~\cite{lattnerLLVMCompilationFramework2004}, GNU Compiler Collection~\cite{merrillGenericGimpleNew2003}), programs are represented as some sort of graph-based intermediate representation (IR) rather than a syntax tree.
Here, basic blocks of instructions\footnote{Maximal sequences of instructions which are unconditionally executed together determined by program control flow.} form the nodes, and terminator instructions (e.g.\ jumps, branches, and other control flow operations) form the edges.
This allows for optimisations and analyses based on graphical structure, e.g.\ reachability analysis to perform dead-code elimination, or data-flow analysis to perform constant folding.
In essence, this is much closer to $\lambda^\approx_{\text{lsub}}$-calculus: the string diagram equivalence there is abstracting away from the particular syntax of a term, in much the same way that LLVM IR abstracts away from the raw syntax of the source program.
Thus, an understanding of e-graphs in this context is valuable for the applicability of equality saturation techniques with respect to graph-based IRs which dominate the landscape of modern compiler design.

We will define a monoidal signature whose closed symmetric monoidal theory is the $\lambda^\approx_{\text{lsub}}$-calculus extended by tupling of terms and flat natural numbers equipped with basic arithmetic operations.
Let $\Sigma \coloneq (\{ \mathbf{N} \}, \{ \comonoid, \counit \} \cup \mathbb{N} \cup \{ \text{plus}, \text{mult} \}, t)$ where
\begin{align*}
	t\colon \{ \comonoid, \counit \} \cup \mathbb{N} \cup \{ \text{plus}, \text{mult} \} & \to {\{ \mathbf{N} \}}^* \times {\{ \mathbf{N} \}}^*                                                    \\
	t(n)                                                                                 & = ((), (\mathbf{N})),                                & n \in \mathbb{N},                                \\
	t(o)                                                                                 & = ((\mathbf{N}, \mathbf{N}), (\mathbf{N})),          & o \in \{ \comonoid, \text{plus}, \text{mult} \}, \\
	t(\counit)                                                                           & = ((\mathbf{N}), ()).
\end{align*}
The operations that the signature $\Sigma$ avails are copy and delete, denoted by $\comonoid$ and $\counit$ respectively, constants for each natural number, and the binary arithmetic operations $+$ and $\times$.
We interpret the $\Sigma$-terms $\llbracket \tau \rrbracket$ as follows: operations as themselves, $\id_{I}$ and $\id_{\mathbf{N}}$ as the identity function $\lambda x. x$ on the empty tuple $()$ and $\mathbf{N}$ respectively, $\sym_{\mathbf{N}, \mathbf{N}}$ as the swap function $\lambda (x, y). (y, x)$, composition $\tau_1 ; \tau_2$ as the composition function $\lambda x. \llbracket \tau_2 \rrbracket \left(\llbracket \tau_1 \rrbracket x\right)$, and $\tau_1 \otimes \tau_2$ as tupling $\left(\llbracket \tau_1 \rrbracket, \llbracket \tau_2 \rrbracket\right)$.

Note that, in contrast to traditional presentations of the $\lambda$-calculus as a language of (slotted~\cite[Example 1]{slotted-egraphs}) e-graphs~\cite[Figure 10]{EggPaper}, here there is no encoding of the term formers for application, abstraction, and explicit substitution.
Instead, these constructs are handled ambiently by our semantic setting: any closed symmetric monoidal category (and in particular, $\catname{CS}(\Sigma, \mathcal{E})$ for any set of equations $\mathcal{E}$) admits an internal language in the multiplicative fragment of intuitionistic linear logic (a particular type of linear $\lambda$-calculus)~\cite[ยง 1.7.3]{abramskyIntroductionCategoriesCategorical2010}.
In other words, with respect to~\autoref{fig:egraph-strings}, this allows us to \emph{natively} represent abstraction by the rounded boxes of ($\Lambda(f)$), and application by the $\textsf{ev}$ operation with $\beta$- and $\eta$-conversion arising via equality of morphisms in the category (that is, without having to provide them as data in the form of equations in $\mathcal{E}$).
For explicit substitution, we note that the linearity is not desirable; this is why the copy-delete comonoid $(\comonoid, \counit)$ is present: by Fox's theorem~\cite{foxCoalgebrasCartesianCategories1976}, a cartesian category is precisely a monoidal one admitting such a \emph{natural} copy-delete structure.
Thus, we must endow $\mathcal{E}$ with equations stating that $(\comonoid, \counit)$ forms a comonoid, and moreover that it is natural: $\comonoid$ behaves uniformly as a copy map, and $\counit$ behaves as deletion.

\begin{figure}
	\centering
	\begin{subfigure}{0.3\linewidth}
		\begin{lstlisting}[language=ML]
let x = 1 in
let y = 2 in
plus(x, y)
                \end{lstlisting}
		\hrule
		\begin{lstlisting}[language=ML]
let y = 2 in
let x = 1 in
plus(x, y)
                \end{lstlisting}
		\hrule
		\begin{lstlisting}[language=ML]
plus(1, 2)
                \end{lstlisting}
		\caption{Three programs for $1 + 2$}%
		\label{fig:plus-1-2-programs}
	\end{subfigure}
	\hspace{2em}
	\begin{subfigure}{0.2\linewidth}
		\begin{align*}
			        & \text{plus}(x, y)[y/2][x/1] \\
			\approx &                             \\
			        & \text{plus}(x, y)[x/1][y/2] \\
			\approx &                             \\
			        & \text{plus}(1, 2)
		\end{align*}
		\caption{As terms in $\lambda_{\text{lsub}}$}%
		\label{fig:plus-1-2-terms}
	\end{subfigure}
	\hspace{2em}
	\begin{subfigure}{0.2\linewidth}
		\centering
		\tikzfig{figures/plus-1-2}
		\caption{String diagrammatic representation}%
		\label{fig:plus-1-2-string-diagram}
	\end{subfigure}
	\caption{$\approx$-equivalent terms}%
	\label{fig:plus-1-2}
\end{figure}

\autoref{fig:plus-1-2-programs} shows some programs which are semantically equivalent but syntactically distinct.
As alluded to in~\autoref{sec:vs-e-graphs-with-binding}, the traditional (slotted) e-graph approach to modelling the equivalence of these terms (\autoref{fig:plus-1-2-terms}) relies on explicitly encoding substitution operations as e-graph nodes, and their behaviour (the string diagram equivalence relation $\approx$) as rewrite rules, as in~\autoref{fig:e-graph-substitution} --- not only is this more complicated, but it also leads to a blow-up in the state space required to perform equality saturation in any extension of the $\lambda^\approx_{\text{lsub}}$-calculus, because we are really rewriting $\lambda_{\text{lsub}}$-terms and computational resources are spent rewriting between equivalent terms.
\textcolor{cyan}{To illustrate this, let's consider the following equations induced by the graphical equivalence and the $\lambda_{\text{lsub}}$ reduction rules}

\begin{tabular}{lcc}
	\texttt{beta}                  & $(\lambda x . t) u = t[x / u]$                       &                                                                    \\
	\texttt{subst\_same\_var}      & $x[x / u] = u$                                       &                                                                    \\
	\texttt{subst\_diff\_var}      & $y[x / u] = y$                                       & if $x \not \in \mathcal{F}(u)$                                     \\
	\texttt{subst\_application}    & $(uu')[x / v] = u[x / v]u'[x / v]$                   &                                                                    \\
	\texttt{subst\_lambda}         & $(\lambda x . u)[y / v] = \lambda x . (u[y / v])$    & if $x \not \in \mathcal{F}(v)$                                     \\
	\texttt{subst\_interchange\_1} & $(u[x / v])[x' / v'] = (u[x' / v'])[x / v[x' / v']]$ & if $x' \in \mathcal{F}(v)$ and $x \in \mathcal{F}(v')$             \\
	\texttt{subst\_interchange\_2} & $(u[x / v])[x' / v'] = (u[x / v[x' / v']])$          & if $x' \not \in \mathcal{F}(u)$                                    \\
	\texttt{subst\_comm}           & $(u[x / v])[x' / v'] = (u[x' / v'])[x / v]$          & if $x \not \in \mathcal{F}(v')$ and $x' \not \in \mathcal{F}(v)~.$ \\
\end{tabular}

\textcolor{cyan}{These can be encoded in a framework of slotted e-graphs.
	To demonstrate the effect that a particular set of rewrites has on the number of e-nodes of an e-graph, we saturate the lambda term $plus 2 2$ where $plus$ and $2$ are encoded using Church encoding.
	The numbers of e-nodes after the e-graph is saturated for each set of rewrite rules are presented in \autoref{tbl:slotted}.
}

\begin{table}
	\begin{tabular}{lcccc}
		Set of equations & explicit subst & explicit subst & explicit subst & explicit subst \\
		                 &                & + comm         & + interchange  & + interchange  \\
		                 &                &                &                & + comm         \\
		\# of e-nodes    & 161            & 288            & 289            & 356
	\end{tabular}
	\caption{Slotted e-graphs benchmarks}
	\label{tbl:slotted}
\end{table}

\textcolor{cyan}{The \texttt{explicit subst} set of rewrite rules consist of the first five rules above.
	We can see that additionally saturating the e-graph with respect to interchange and commutativity rules increases the number of e-nodes by a factor of 2.
	These are the exact equations that are absorbed by using string-diagrammatic representation of $\lambda$-terms.
	Notably, string diagrams (and (e-)hypergraphs) do not absorb the equation \texttt{subst\_lambda} but we believe it is practically feasible to do rewriting modulo this rule by traversing through the boxes when searching for a redex.
	Furthermore, (cospans of) e-hypergraphs, as presented in \autoref{sec:closed-e-hyp}, do not absorb the equations for associativity, commutativity and unitality for $\comonoid$ and $\counit$, but the constraints on the cospans and the boundary complement may be relaxed to absorb those as well by following the work of~\cite{zanassi_comonoid} with which our approach is completely compatible.}

In contrast, in our framework, $\lambda^\approx_{\text{lsub}}$-terms are directly modelled as string diagrams (\autoref{fig:plus-1-2-string-diagram}\footnote{Note that dashed boxes are elided for convenience here because no rewriting has occurred.}).
We do however note that the traditional approach is more flexible, in the sense that it may model more theories with binders (e.g.\ $\pi$-calculus), whereas our approach is essentially specialised to $\lambda$-calculus, relying heavily on the metatheoretic internal language of the ambient setting.

As a second example, we may wish to incorporate the optimisation ${\text{plus} (x, x) \leadsto \text{mult} (x, 2)}$ in our toy theory.
This corresponds to endowing $\mathcal{E}$ with the equation of string diagrams:
\[
	\tikzfig{figures/plus-copy}
	\quad
	=
	\quad
	\tikzfig{figures/mult-2}
	\;
	.
\]
Now, in our semantic model, this rewrite can be non-destructively applied to model one step of e-graph saturation:
\[
	\tikzfig{figures/plus-copy-rewrite-1}
	\quad
	\equiv
	\quad
	\tikzfig{figures/plus-copy-rewrite-2}
	\quad
	\to
	\quad
	\tikzfig{figures/plus-copy-rewrite-3}
	\;
	.
\]
Here, $\equiv$ is a definitional equality arising from the idempotence in the Hom semilattice, and $\to$ is an application of DPO rewriting using the previous equation along the right branch.
In isolation, this isn't particularly interesting, but the important observation is that this rewriting all happens \emph{locally} in the context of a bigger diagram.

From a practical perspective, the encoding of string diagrams as (e-)hypergraphs provides a normal form for string diagram equivalence classes of terms.
As a data structure, this provides an efficient representation upon which to build an implementation of this theory as a fully fledged \enquote{e-graphs for string diagram rewriting}, using DPO rewriting as a primitive to implement the standard e-graph operations.
We leave this as future work, noting its applications to not only $\lambda^\approx_{\text{lsub}}$-calculus, but also other monoidal theories where there are two levels of rewriting:
\begin{enumerate}
	\item \enquote{bureaucratic} reassociation and reparenthesisation, absorbed into isotopy of string diagrams (here, a fragment of string diagram equivalence of $\lambda_{\text{lsub}}$-terms);
	\item algebraic identities arising from the semantics of the theory (e.g. ${\text{plus} (x, x) \leadsto \text{mult} (x, 2)}$ for arithmetic).
\end{enumerate}
One such theory is the ZX calculus~\cite{coeckeInteractingQuantumObservables2011}.
