\section{Application --- $\lambda^\sim_{\text{lsub}}$-calculus}

In this section, we show the utility of our theory by demonstrating how it can accommodate the \emph{linear substitution calculus} $\lambda_{\text{lsub}}$ of~\citet[ยง 2]{accattoli2014nonstandard}.
We summarise the linear substitution calculus as the $\lambda$-calculus with an additional term former representing explicit substitution; i.e.\ terms are generated by the grammar
\[
	t \coloneqq x \mid t t \mid \lambda x. t \mid t [x/t],
\]
where $x$ is a variable drawn from some countably infinite set, $t u$ is an application, and $\lambda x. t$ is an abstraction, as in standard $\lambda$-calculus.
The term $t [x / u]$ is an explicit substitution of the variable $x$ for the term $u$ in the term $t$.

The notions of context $C[-]$, bound and free variable are as usual, with the addition that $\textsf{fv} (t [x/u]) \coloneq \textsf{fv} (t) \setminus \{ x \} \cup \textsf{fv} (u)$.
Write $C \llbracket t \rrbracket$ for the term given by substitution of the hole in the context $C[-]$ for the term $t$, under the additional restriction that the free variables of $t$ are not captured (via abstraction or explicit substitution) by $C$.
In addition to the $\beta$- and $\eta$-reduction rules of standard $\lambda$-calculus, there are reduction rules to account for this explicit substitution which \enquote{perform} the substitution or commute it with $\beta$-reduction:
\begin{align*}
	(\lambda x. t) L u              \quad & \leadsto \quad t[x/u] L,                                                    \\
	C \llbracket x \rrbracket [x/t] \quad & \leadsto \quad C \llbracket u \rrbracket [x/t],                             \\
	t [x/u]                         \quad & \leadsto \quad t,                               & x \notin \textsf{fv} (t),
\end{align*}
where $L$ is a finite list of substitutions of the form $[x/u] [y/v] \ldots$.

In programming terms, this explicit substitution can be used to model \textbf{let}-bindings and sharing.
For instance, the ML-style term $\textbf{let} \; x = 1 \; \textbf{in} \; \text{plus} (x, x)$ is formally represented as the term $\text{plus} (x, x) [x / 1]$ in this calculus\footnote{Technically speaking, in this case we mean the extension of this calculus with flat natural numbers equipped with a binary operation $\text{plus}$.}.
In this case, the variable $x$ is valued in the constant $1$, but one could imagine instead that $x$ is to be substituted for the result of some expensive computation which we do not desire to repeat twice unnecessarily --- in this sense, the sharing of both operands of the operation $\text{plus}$ is captured by the explicit substitution.

\emph{Graphical equivalence} $\sim$ of $\lambda_{\text{lsub}}$-terms is augmentation of $\alpha$-equivalence of terms with the additional stipulations that
\begin{align*}
	t [x/u] [y/v] \quad        & \sim \quad t [y/v] [x/u],        & x \notin \textsf{fv} (v) \land y \notin \textsf{fv} (u), \\
	(\lambda y. t) [x/u] \quad & \sim \quad \lambda y. (t [x/u]), & y \notin \textsf{fv} (u),                                \\
	(t v) [x/u] \quad          & \sim \quad t [x/u] v,            & x \notin \textsf{fv} (u),
\end{align*}
closed under contexts, transitivity, symmetry, and reflexivity.
Put simply, it is the stipulation that \textbf{let}-bindings may be freely reordered without changing the meaning of the term\footnote{Recall that our setting is \emph{pure}, in the sense that no sequencing of effects is meaningful.}.
The $\lambda^\sim_{\text{lsub}}$-calculus is given by these graphical equivalence classes of terms with the reduction relation defined by that of the $\lambda_{\text{lsub}}$-calculus modulo graphical equivalence.

This calculus is explicitly designed to capture the representation of terms as proof nets: for two terms $t, u$ in the $\lambda_{\text{lsub}}$-calculus, $t \sim u$ if and only if both map to the same proof net~\cite{?}.
It turns out that the same fact is true for the representation of terms as string diagrams~\cite{ghica2024equivalencehypergraphsegraphsmonoidal} instead of proof terms, and in this fact we can exploit the string diagram setting of e-hypergraphs to absorb the reductions arising due to graphical equivalence into our representation rather than explicitly providing them as equations attached to a symmetric monoidal theory presenting the $\lambda^\sim_{\text{lsub}}$-calculus.

Before we proceed to demonstrate this, we first wish to discuss the relevance of this calculus in the domain of e-graphs.
E-graphs excel as a toolkit for compiler optimisation, facilitating the rewriting of programs into more efficient forms by equality saturation.
The theoretical study of this is the field of term rewriting, where programs are often simplistically represented as (the abstract syntax of) terms in the $\lambda$-calculus.
However, in a modern optimising compiler (e.g.\ LLVM~\cite{lattnerLLVMCompilationFramework2004}, GNU Compiler Collection~\cite{merrillGenericGimpleNew2003}), programs are represented as some sort of graph-based intermediate representation (IR) rather than a syntax tree.
Here, basic blocks of instructions\footnote{Maximal sequences of instructions which are unconditionally executed together determined by program control flow.} form the nodes, and terminator instructions (e.g.\ jumps, branches, and other control flow operations) form the edges.
This allows for optimisations and analyses based on graphical structure, e.g.\ reachability analysis to perform dead-code elimination, or data-flow analysis to perform constant folding.
In essence, this is much closer to $\lambda^\sim_{\text{lsub}}$-calculus: the graphical equivalence there is abstracting away from the particular syntax of a term, in much the same way that LLVM IR abstracts away from the raw syntax of the source program.
Thus, an understanding of e-graphs in this context is valuable for the applicability of equality saturation techniques with respect to graph-based IRs which dominate the landscape of modern compiler design.

We will define a monoidal signature whose closed symmetric monoidal theory is the $\lambda^\sim_{\text{lsub}}$-calculus extended by tupling of terms and flat natural numbers equipped with basic arithmetic operations.
Let $\Sigma \coloneq (\{ \mathbf{N} \}, \{ \comonoid, \counit \} \cup \mathbb{N} \cup \{ \text{plus}, \text{mult} \}, t)$ where
\begin{align*}
	t\colon \{ \comonoid, \counit \} \cup \mathbb{N} \cup \{ \text{plus}, \text{mult} \} & \to {\{ \mathbf{N} \}}^* \times {\{ \mathbf{N} \}}^*                                                    \\
	t(n)                                                                                 & = ((), (\mathbf{N})),                                & n \in \mathbb{N},                                \\
	t(o)                                                                                 & = ((\mathbf{N}, \mathbf{N}), (\mathbf{N})),          & o \in \{ \comonoid, \text{plus}, \text{mult} \}, \\
	t(\counit)                                                                           & = ((\mathbf{N}), ()).
\end{align*}
The operations that the signature $\Sigma$ avails are copy and delete, denoted by $\comonoid$ and $\counit$ respectively, constants for each natural number, and the binary arithmetic operations $+$ and $\times$.
We interpret the $\Sigma$-terms $\llbracket \tau \rrbracket$ as follows: fully applied operations as themselves, $\id_{I}$ and $\id_{\mathbf{N}}$ as the identity function $\lambda x. x$ on the empty tuple $()$ and $\mathbf{N}$ respectively, $\sym_{\mathbf{N}, \mathbf{N}}$ as the swap function $\lambda (x, y). (y, x)$, composition $\tau_1 ; \tau_2$ as the composition function $\lambda x. \llbracket \tau_2 \rrbracket \left(\llbracket \tau_1 \rrbracket x\right)$, and $\tau_1 \otimes \tau_2$ as tupling $\left(\llbracket \tau_1 \rrbracket, \llbracket \tau_2 \rrbracket\right)$.

Note that, in contrast to traditional presentations of the $\lambda$-calculus as a language of (slotted~\cite[Example 1]{slotted-egraphs}) e-graphs~\cite[Figure 10]{EggPaper}, here there is no encoding of the term formers for application, abstraction, and explicit substitution.
Instead, these constructs are handled ambiently by our semantic setting: any closed symmetric monoidal category (and in particular, $\catname{CS}(\Sigma, \mathcal{E})$ for any set of equations $\mathcal{E}$) admits an internal language in the multiplicative fragment of intuitionistic linear logic (a particular type of linear $\lambda$-calculus)~\cite[ยง 1.7.3]{abramskyIntroductionCategoriesCategorical2010}.
In other words, with respect to~\autoref{fig:egraph-strings}, this allows us to \emph{natively} represent abstraction by the rounded boxes of ($\Lambda(f)$), and application by the $\textsf{ev}$ operation with $\beta$- and $\eta$-conversion arising via equality of morphisms in the category (that is, without having to provide them as data in the form of equations in $\mathcal{E}$).
For explicit substitution, we note that the linearity is not desirable; this is why the copy-delete comonoid $(\comonoid, \counit)$ is present: by Fox's theorem~\cite{foxCoalgebrasCartesianCategories1976}, a cartesian category is precisely a monoidal one admitting such a \emph{natural} copy-delete structure.
Thus, we must endow $\mathcal{E}$ with equations stating that $(\comonoid, \counit)$ forms a comonoid, and moreover that it is natural: $\comonoid$ behaves uniformly as a copy map, and $\counit$ behaves as deletion.
